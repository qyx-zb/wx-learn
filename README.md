# wx-learn
微信小程序相关

前言：我从事小程序开发有两年的时间，原生的开发，多个平台，有微信的，百度的，快应用，字节跳动等，两年的时间，也遇到过各种各样的问题，一直想着总结一下，但是总是拖延，作为一名前端开发人员，我们首先要学会如何开发，但是当你具有一定的开发经验之后，不妨深入思考，毕竟如果你还停留在应用开发层面，那你就OUT了，今天带大家探讨下小程序框架本身底层实现的一些技术细节，让我们从小程序的运行机制来深度了解小程序。

关于微信小程序：    
微信小程序底层原理  
开发流程    
流行的框架  
实战经验总结


### 微信小程序底层原理  

我们都知道页面渲染的方式主要有三种:
1. web渲染
2. Native原生渲染
3. web与Native两者掺杂，即Hybrid渲染。

而小程序的呈现形式为第三种。

#### 与h5页面的区别
那么，小程序和普通的 h5 页面到底有什么区别呢？
- 运行环境：小程序基于浏览器内核重构的内置解析器，而 h5 的宿主环境是浏览器。所以小程序中没有 DOM 和 BOM 的相关 API ， jQuery 和一些 NPM 包都不能在小程序中使用；
- 系统权限：小程序能获得更多的系统权限，如网络通信状态、数据缓存能力等；
- 渲染机制：小程序的逻辑层和渲染层是分开的，而 h5 页面 UI 渲染跟 JavaScript 的脚本执行都在一个单线程中，互斥。所以 h5 页面中长时间的脚本运行可能会导致页面失去响应。

其实，小程序开发过程中我们面对的是 iOS 和 Android 微信客户端和辅助开发的小程序开发者工具。根据官方文档，这三大运行环境也是有所区别的：

运行环境|逻辑层|渲染层 
---|---|---
iOS|JavaScriptCore|WKWebView
Android|	X5 JSCore|	X5浏览器
小程序开发者工具|	NWJS|	Chrome WebView

所以微信小程序介于 web 端和原生 App 之间，能够丰富调用功能接口，同时又跨平台。



#### 小程序的架构
##### 双线程模型
小程序的渲染层和逻辑层分别由2个线程管理：

- 渲染层：界面渲染相关的任务全都在 WebView 线程里执行。
- 逻辑层：采用 JsCore 线程运行JS脚本。

 视图层和逻辑层通过系统层的 WeixinJsBridage 进行通信：逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。

一个小程序存在多个界面，所以渲染层存在多个webview线程。逻辑层和渲染层的通信会由Native（微信客户端）做中转，逻辑层发送网络请求也会经由Native转发。

`小程序的UI视图和逻辑处理是用多个webview实现的，逻辑处理的JS代码全部加载到一个Webview里面，称之为AppService，整个小程序只有一个，并且整个生命周期常驻内存，而所有的视图（wxml和wxss）都是单独的Webview来承载，称之为AppView。所以一个小程序打开至少就会有2个webview进程，正式因为每个视图都是一个独立的webview进程，考虑到性能消耗，小程序不允许打开超过5个层级的页面，当然同是也是为了体验更好`


（页面渲染的具体流程是：在渲染层，宿主环境会把 WXML 转化成对应的 JS 对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的 setData 方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面）

![image](https://raw.githubusercontent.com/qyx-zb/wx-learn/master/8.png)

双线程模型是小程序框架与业界大多数前端 Web 框架不同之处。基于这个模型，可以更好地管控以及提供更安全的环境。缺点是带来了无处不在的异步问题（任何数据传递都是线程间的通信，也就是都会有一定的延时），不过小程序在框架层面已经封装好了异步带来的时序问题。

##### 组件系统
我们知道小程序是有自己的组件的，这些基本组件就是基于 Exparser 框架。

小程序中，所有节点树相关的操作都依赖于 Exparser ，包括 WXML 到页面最终节点树的构建、 CreateSelectorQuery 调用和自定义组件特性等。在WAWebview.js里有个对象叫exparser，它完整的实现小程序里的组件，看具体的实现方式，思路上跟w3c的web components规范神似，但是具体实现上是不一样的，我们使用的所有组件，都会被提前注册好，在Webview里渲染的时候进行替换组装。 
exparser有个核心方法： 
- regiisterBehavior: 注册组件的一些基础行为，供组件继承
- registerElement：注册组件，跟我们交互接口主要是属性和事件

组件触发事件（带上webviewID），调用WeixinJSBridge的接口，publish到native，然后native再分发到AppService层指定webviewID的Page注册事件处理方法。

微信小程序也支持自定义组件，用法和组件间通信类似于 Vue 。

`Exparser是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础支持。小程序内所有组件，包括内置组件和自定义组件，都有Exparser组织管理。`


##### 原生组件
在内置组件中，有一些组件并不完全在 Exparser 的渲染体系下，而是由客户端原生参与组件的渲染。比如说 Map 组件,canvas组件，video组件等。它们渲染的层级比在 WebView 层渲染的普通组件要高。

引入原生组件的优点是：
- 绕过 setData、数据通信和重渲染流程，使渲染性能更好。
- 扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力。
体验更好，同时也减轻 WebView 的渲染工作。比如像地图组件（map）这类较复杂的组件，其渲染工作不占用 WebView 线程，而交给更高效的客户端原生处理。
 

原生组件的渲染过程：
1. 组件被创建，包括组件属性会依次赋值。
2. 组件被插入到 DOM 树里，浏览器内核会立即计算布局，此时我们可以读取出组件相对页面的位置（x, y坐标）、宽高。
组件通知客户端，客户端在相同的位置上，根据宽高插入一块原生区域，之后客户端就在这块区域渲染界面。
3. 当位置或宽高发生变化时，组件会通知客户端做相应的调整

##### 运行机制
1. **启动**
- 热启动：：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动；
- 冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即冷启动。
![image](https://raw.githubusercontent.com/qyx-zb/wx-learn/master/9.png)

2. **销毁**         
只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。

##### 更新机制

开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。

小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。

所以如果想让用户使用最新版本的小程序，可以利用 wx.getUpdateManager 做个检查更新的功能：
```
checkNewVersion() {
    const updateManager = wx.getUpdateManager();
    updateManager.onCheckForUpdate((res) => {
      console.log('hasUpdate', res.hasUpdate);
      // 请求完新版本信息的回调
      if (res.hasUpdate) {
        updateManager.onUpdateReady(() => {
          this.setData({
            hasNewVersion: true
          });
        });
      }
    });
  }
```


###### evaluate Javascript

视图层和逻辑层的数据传输，实际上通过两边提供的evaluateJavascript实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份JS脚本，在通过JS脚本的形式传递到两边独立环境。

因为evaluateJavascript的执行会受很多方面的影响，数据到达视图层并不是实时的。随意我们的setData函数将数据从逻辑层发送到视图层，是异步的。


#### 模板数据绑定方案
1. 解析语法生成AST
2. 根据AST结果生成DOM
3. 将数据绑定更新至模板

最容易引发性能问题的主要是第三点，而关于数据更新的解决方案，React首先提出了虚拟DOM的设计，而现在也基本被大部分框架吸收，小程序也不例外。

#### 虚拟 DOM 机制 virtual Dom

用JS对象模拟DOM树 -> 比较两个DOM树 -> 比较两个DOM树的差异 -> 把差异应用到真正的DOM树上

1. 在渲染层把WXML转化成对应的JS对象
2. 在逻辑层发生数据变更的时候，通过宿主环境提供的setData方法把数据从逻辑层传递到Native，再转发到渲染层
3. 经过对比前后差异，把差异应用在原来的DOM树上，更新界面

#### 小程序的基础库

小程序的基础库是JavaScript编写的，它可以被注入到渲染层和逻辑层运行。主要用于：

在渲染层，提供各类组件来组件页面的元素

在逻辑层，提供各种API来处理各种元素。

处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑

 

小程序的渲染层和逻辑层是两个线程管理，两个线程各自注入了基础库。

小程序的基础库不会打包在小程序的代码中，它会被提前内置在微信客户端。这样可以：

降低业务小程序的代码包大小

可以单独修复基础库中的Bug，无需修改到业务小程序的代码包


#### 双线程的渲染机制
双线程的渲染，其实是结合了前面的一系列机制。
1. 通过模板数据绑定和虚拟DOM机制，小程序提供了带有数据绑定语法的DSL，渲染层来描述页面结构。

```html
<view> {{ message }} </view> 
<view wx:if="{{condition}}"> </view> 
<checkbox checked="{{false}}"> </checkbox>
```

2. 小程序在逻辑层提供了设置页面数据的api
```
this.setData({
    key : value
});
```
3. 逻辑层需要更改页面时，只要把修改后的data通过setData传到渲染层。

传输的数据，会转换为字符串形式传输，故应避免传递大量数据。
4. 渲染层会根据渲染机制重新生成虚拟DOM树，并更新到对应的DOM树上，引起界面变化。

注意：不能同时打开超过5个窗口，打包文件不能大于1M，dom对象不能大于16000个等，这些都是为了保证更好的体验，微信小程序的基础底层架构大概就这么多，大家可以花时间多研究下原理。

